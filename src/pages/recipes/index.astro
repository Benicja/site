---
export const prerender = false;
import { getCollection } from 'astro:content';
import Layout from '../../layouts/Layout.astro';
import RecipeCard from '../../components/RecipeCard.astro';
import { SESSION_COOKIE, getUserFromSession } from '../../lib/auth';
import { getRecipeHearts, getUserHearts } from '../../lib/hearts';
import { supabaseAdmin } from '../../lib/supabase';

// Get current user
const sessionId = Astro.cookies.get(SESSION_COOKIE)?.value;
const user = sessionId ? await getUserFromSession(sessionId) : null;

// Get all recipes
const allRecipes = await getCollection('recipes');

// Get deleted recipes from Supabase
const { data: deletedRecipes } = await supabaseAdmin
  .from('deleted_recipes')
  .select('recipe_slug');

const deletedSlugs = new Set((deletedRecipes || []).map(d => d.recipe_slug));

// Filter out deleted recipes
const recipes = allRecipes.filter(recipe => !deletedSlugs.has(recipe.slug));

// Load custom recipe order from Supabase
let recipeOrder: string[] = [];
try {
  const { data: orderData } = await supabaseAdmin
    .from('recipe_order')
    .select('order_slugs')
    .eq('id', 'primary')
    .single();
  
  if (orderData) {
    recipeOrder = orderData.order_slugs || [];
  }
} catch (error) {
  // No order exists yet, use default sorting
}

// Sort recipes: first by custom order if exists, then by publishDate (newest first), then alphabetically
const sortedRecipes = recipes.sort((a, b) => {
  const aIndex = recipeOrder.indexOf(a.slug);
  const bIndex = recipeOrder.indexOf(b.slug);
  
  // If both are in custom order, sort by that
  if (aIndex !== -1 && bIndex !== -1) {
    return aIndex - bIndex;
  }
  // If only one is in custom order, it comes first
  if (aIndex !== -1) return -1;
  if (bIndex !== -1) return 1;
  
  // Otherwise, sort by publishDate (newest first), then alphabetically
  const dateDiff = (b.data.publishDate?.getTime() || 0) - (a.data.publishDate?.getTime() || 0);
  if (dateDiff !== 0) return dateDiff;
  return a.data.title.localeCompare(b.data.title);
});

// Get heart data
const globalHearts = await getRecipeHearts();
const userHearts = user ? await getUserHearts(user.user_email) : new Set();

const formatCategories = (value: unknown): string => (Array.isArray(value) ? value.join(',') : String(value));
---

<Layout title="Recipes" description="A collection of our favorite family recipes." user={user}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-6 pb-4 sm:pb-10">
    {recipes.length > 0 ? (
      <div class="space-y-6">
        {/* Search & Filters */}
        <div class="space-y-4">
          <div class="w-full">
            <div class="relative">
              <input 
                type="text" 
                id="recipe-search" 
                placeholder="Search recipes..." 
                class="w-full px-5 py-3 bg-white border border-gray-300 rounded-xl focus:outline-none focus:border-gray-600 transition-colors duration-[250ms] font-normal text-black text-base"
                inputmode="search"
                autocomplete="off"
                enterkeyhint="search"
                autocapitalize="off"
                spellcheck="false"
                tabindex="0"
              />
              <div class="absolute right-5 top-1/2 -translate-y-1/2 text-gray-600">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center gap-2" data-filter-group>
            {[ 'Breakfast', 'Dinner', 'Dessert' ].map(cat => (
              <button 
                type="button"
                class="filter-btn px-4 py-1.5 rounded-full border border-gray-200 bg-white text-[10px] font-bold uppercase tracking-widest text-gray-600 transition-all duration-100 select-none data-[active=true]:bg-gray-50 data-[active=true]:text-gray-950 data-[active=true]:border-gray-950 [&:not([data-active=true])]:hover:text-gray-900 [&:not([data-active=true])]:hover:border-gray-400"
                data-filter="category"
                data-value={cat.toLowerCase()}
                data-active="false"
              >
                {cat}
              </button>
            ))}
            
            {user && (
              <button 
                type="button"
                class="filter-btn px-4 py-1.5 rounded-full border border-gray-200 bg-white text-[10px] font-bold uppercase tracking-widest text-gray-600 transition-all duration-100 select-none flex items-center gap-2 data-[active=true]:bg-red-50 data-[active=true]:text-red-700 data-[active=true]:border-red-900 [&:not([data-active=true])]:hover:text-gray-900 [&:not([data-active=true])]:hover:border-gray-400"
                data-filter="hearted"
                data-active="false"
              >
                <svg class="w-3.5 h-3.5 fill-none stroke-current transition-all duration-100" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                </svg>
                Favourites
              </button>
            )}
          </div>
        </div>

        <section>
          <div id="recipes-grid" class="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-x-8 md:gap-y-8">
            {sortedRecipes.map((recipe, index) => (
              <div 
                class="recipe-item opacity-0 invisible" 
                style={`--stagger: ${index}; content-visibility: auto; contain-intrinsic-size: 1px 400px;`}
                data-title={recipe.data.title.toLowerCase()}
                data-category={formatCategories(recipe.data.category).toLowerCase()}
                data-hearted={userHearts.has(recipe.slug).toString()}
              >
                <RecipeCard 
                  recipe={recipe} 
                  user={user}
                  isHearted={userHearts.has(recipe.slug)}
                  heartCount={(globalHearts as any)[recipe.slug] || 0}
                />
              </div>
            ))}
          </div>
          <div id="no-results" class="hidden py-32 text-center">
             <h2 class="text-2xl font-serif text-gray-400">No recipes match your search.</h2>
          </div>
        </section>
      </div>
    ) : (
      <div class="py-32 text-center border-t border-gray-100">
         <h2 class="text-2xl font-serif text-gray-400">Our recipe book is currently empty.</h2>
         <p class="text-sm text-gray-400 mt-4 uppercase tracking-widest font-bold">Check back soon for upcoming treats.</p>
      </div>
    )}
  </div>

  <style is:global>
    @keyframes entry-fade-in {
      from { 
        opacity: 0; 
        transform: translateY(10px);
        visibility: hidden;
      }
      to { 
        opacity: 1; 
        transform: translateY(0);
        visibility: visible;
      }
    }

    .recipe-item.reveal {
      animation: entry-fade-in 0.4s ease-out forwards;
    }
  </style>

  <script>
    function initSearch() {
      const searchInput = document.getElementById('recipe-search') as HTMLInputElement | null;
      const recipeItems = document.querySelectorAll('.recipe-item') as NodeListOf<HTMLElement>;
      const recipesGrid = document.getElementById('recipes-grid');
      const noResults = document.getElementById('no-results');
      const filterBtns = document.querySelectorAll('.filter-btn');
      const filterGroup = document.querySelector('[data-filter-group]');

      if (!searchInput) return;

      // STAGGERED REVEAL on initial load
      // We reveal in small batches to avoid frame spikes
      const revealItems = () => {
        recipeItems.forEach((item, i) => {
          // Calculate a small delay for each (e.g. 15ms per item)
          // This spreads the "creation" work across many frames
          setTimeout(() => {
            item.classList.remove('opacity-0', 'invisible');
            item.classList.add('reveal');
          }, i * 12);
        });
      };
      
      revealItems();


      let activeCategory: string | null = null;
      let showHeartedOnly = false;

      const normalize = (str: string) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

      function updateGrid() {
        if (!searchInput || !noResults || !recipesGrid) return;

        const query = normalize(searchInput.value.trim());
        let hasResults = false;


        recipeItems.forEach(item => {
          const title = normalize(item.getAttribute('data-title') || '');
          const category = item.getAttribute('data-category');
          const isHearted = item.getAttribute('data-hearted') === 'true';

          let matchesSearch = title.includes(query);
          let matchesCategory = true;
          if (activeCategory) {
            const categories = (category || '')
              .split(',')
              .map(cat => cat.trim().toLowerCase())
              .filter(Boolean);
            matchesCategory = categories.includes(activeCategory);
          }
          let matchesHearted = !showHeartedOnly || isHearted;

          const shouldShow = matchesSearch && matchesCategory && matchesHearted;
          item.hidden = !shouldShow;
          if (shouldShow) {
            hasResults = true;
          }
        });

        if (hasResults) {
          noResults.classList.add('hidden');
          recipesGrid.classList.remove('hidden');
        } else {
          noResults.classList.remove('hidden');
          recipesGrid.classList.add('hidden');
        }
      }

      function handleFilterClick(btn: HTMLElement) {
        const type = btn.getAttribute('data-filter');
        const value = btn.getAttribute('data-value');
        const wasActive = btn.getAttribute('data-active') === 'true';

        // If already active, just toggle off
        if (wasActive) {
          btn.setAttribute('data-active', 'false');
          if (type === 'category') {
            activeCategory = null;
          } else if (type === 'hearted') {
            showHeartedOnly = false;
            const heartSvg = btn.querySelector('svg');
            heartSvg?.classList.remove('fill-current');
          }
          updateGrid();
          return;
        }

        // Deselect all filter buttons
        filterBtns.forEach(b => {
          b.setAttribute('data-active', 'false');
          if (b.getAttribute('data-filter') === 'hearted') {
            const heartSvg = b.querySelector('svg');
            heartSvg?.classList.remove('fill-current');
          }
        });
        activeCategory = null;
        showHeartedOnly = false;

        // Activate the clicked button
        btn.setAttribute('data-active', 'true');
        if (type === 'category') {
          activeCategory = value ? value.toLowerCase() : null;
        } else if (type === 'hearted') {
          showHeartedOnly = true;
          const heartSvg = btn.querySelector('svg');
          heartSvg?.classList.add('fill-current');
        }
        updateGrid();
      }

      // Handle Category/Hearted Buttons (delegated)
      filterGroup?.addEventListener('click', (event) => {
        const rawTarget = event.target as HTMLElement | null;
        const btn = rawTarget?.closest('.filter-btn') as HTMLElement | null;
        if (!btn) return;
        handleFilterClick(btn);
      });

      // Fallback: bind directly to buttons (guards against delegation issues)
      filterBtns.forEach(btn => {
        if (btn.getAttribute('data-inited') === 'true') return;
        btn.setAttribute('data-inited', 'true');
        btn.addEventListener('click', (event) => {
          event.preventDefault();
          handleFilterClick(btn as HTMLElement);
        });
      });


      // Prevent auto-focus on mobile (do not focus on load)
      // Only add event listener for input
      searchInput.addEventListener('input', updateGrid);

      // Check URL for initial category
      const urlParams = new URLSearchParams(window.location.search);
      const initialCat = urlParams.get('category');
      if (initialCat) {
        const targetBtn = Array.from(filterBtns).find(b => b.getAttribute('data-value') === initialCat);
        if (targetBtn) (targetBtn as HTMLElement).click();
      }

      function hydrateCardElement(item: HTMLElement, slug: string, data: any) {
        const card = item.querySelector('[data-recipe-slug]');
        if (card) card.setAttribute('data-recipe-slug', slug);
        
        // Update item data attributes for search/filter
        item.setAttribute('data-title', data.title.toLowerCase());
        item.setAttribute('data-category', data.category.toLowerCase());

        // Update card title
        const titleLink = item.querySelector('.recipe-link');
        if (titleLink) {
          titleLink.textContent = data.title;
          titleLink.setAttribute('href', `/recipes/${slug}`);
        }
        
        // Update image link
        const imageLink = item.querySelector('a.block.group');
        if (imageLink) {
          imageLink.setAttribute('href', `/recipes/${slug}`);
        }

        // Update heart button
        const heartBtn = item.querySelector('.heart-button');
        if (heartBtn) {
          heartBtn.setAttribute('data-slug', slug);
          heartBtn.setAttribute('data-hearted', 'false');
          const heartCount = item.querySelector('.heart-count');
          if (heartCount) heartCount.textContent = '0';
        }

        // Update description
        const desc = item.querySelector('p.text-gray-500');
        if (desc) desc.textContent = data.description;

        // Update category tags
        const tags = item.querySelectorAll('.category-tag');
        tags.forEach((tag: Element) => {
          const t = tag as HTMLElement;
          t.textContent = data.category;
          t.setAttribute('data-category', data.category);
          t.setAttribute('href', `/recipes?category=${data.category.toLowerCase()}`);
        });

        // Update image
        const img = (item.querySelector('.hydrate-image') || item.querySelector('img')) as HTMLImageElement | null;
        const fallback = item.querySelector('.hero-fallback');
        if (img && data.featured_image) {
          img.src = data.featured_image;
          img.alt = data.title;
          
          // Try loading from IndexedDB if it was recently added
          const win = window as any;
          if ( win.recipeImageCache ) {
            win.recipeImageCache.get(data.featured_image).then((cachedUrl: string | null) => {
              if (cachedUrl) img.src = cachedUrl;
            });
          }

          img.classList.remove('hidden');
          if (fallback) fallback.classList.add('hidden');
        }

        // Update total time
        const totalTime = (data.prep_time || 0) + (data.cook_time || 0);
        const timeSpan = item.querySelector('.text-xs.md\\:text-sm.font-light.lowercase.text-gray-600');
        if (timeSpan) timeSpan.textContent = `${totalTime} min`;

        // Show item
        item.classList.remove('opacity-0', 'invisible');
        item.style.opacity = '1';
        item.style.visibility = 'visible';
      }

      function hydrateCards() {
        const grid = document.getElementById('recipes-grid');
        const currentItems = document.querySelectorAll('.recipe-item');
        const existingSlugs = new Set();

        // Hydrate existing cards
        currentItems.forEach(item => {
          const card = item.querySelector('[data-recipe-slug]');
          if (!card) return;
          const slug = card.getAttribute('data-recipe-slug');
          if (!slug) return;
          existingSlugs.add(slug);

          const cacheKey = 'recipe_pending_v1_' + slug;
          const raw = localStorage.getItem(cacheKey);
          if (!raw) return;

          try {
            const { timestamp, data } = JSON.parse(raw);
            if (Date.now() - timestamp > 10 * 60 * 1000) {
              localStorage.removeItem(cacheKey);
              return;
            }

            hydrateCardElement(item as HTMLElement, slug, data);
          } catch (e) {}
        });

        // Inject new cards from cache
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('recipe_pending_v1_')) {
            const slug = key.replace('recipe_pending_v1_', '');
            if (!existingSlugs.has(slug)) {
              try {
                const itemRaw = localStorage.getItem(key);
                if (!itemRaw) continue;
                
                const { timestamp, data } = JSON.parse(itemRaw);
                if (Date.now() - timestamp < 10 * 60 * 1000) {
                  const template = currentItems[0];
                  if (template && grid) {
                    const newItem = template.cloneNode(true) as HTMLElement;
                    grid.prepend(newItem);
                    hydrateCardElement(newItem, slug, data);
                  }
                }
              } catch (e) {}
            }
          }
        }

        // Re-run grid update to apply current filters to new cards
        updateGrid();
      }

      hydrateCards();
    }

    // Re-initialize after view transitions
    document.addEventListener('astro:page-load', initSearch);
  </script>
</Layout>